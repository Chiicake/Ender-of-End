# 项目设计文档

> 目标：用纯视觉输入实现 3D 动作网游自动化（2FPS 决策、33ms tick 执行）。
>
> 核心策略（A2 + 两项改动 + 两点训练对齐落地）：
> - **Long/Mid Goals 外置**（脚本/任务图提供，不让模型靠短片段猜长期语义）
> - **Planner 低频生成 Short Goal（用 DSL 表达）**；**Planner 每次读取 MCP：最近 30–60 秒事件 + Top-K 语义相关历史尝试/事件**
> - **Controller 高频执行 Short Goal → 输出 action-only**（500ms，内部 15×33ms）
> - **MCP 为 Timeline Log + Retrieval**：写入 event_log/state_summary/attempt_log/step 迁移；支持 recent window 与 topK 检索
> - **EventGate 分级触发器（L0/L1/L2）**：L0 极便宜检测持续运行；L1 便宜 UI 检测；L2 重感知仅在 L0/L1 触发时运行
> - **训练对齐点 1（Planner Retrieval-aware）**：训练集样本中必须显式构造 `retrieved_memory={recent_window_events, topK_related}`（由 Dataset Builder 从日志自动生成），否则 Planner 学不会“用检索信息做策略切换”
> - **训练对齐点 2（Controller Plan Span）**：每个 `short_goal_dsl` 必须绑定一个生效区间（plan span），Dataset Builder 将其分配到区间内每个 `(image_t, action_t)`，并用 evidence/重规划/干扰事件截断，才能得到干净的 conditional BC 数据
> - **单底座模型 + 双 LoRA 切换**：Planner-LoRA / Controller-LoRA（按角色调用切换）

---

## 0. 全局时间尺度与动作协议

### 0.1 采样与执行
- 决策频率：**2 FPS**，每 **500ms** 生成一次动作
- 动作细分：每次输出包含 **15 组按键**（每组代表 **33ms**）

### 0.2 动作字符串协议（Controller 输出必须严格符合）
```
<|action_start|>dx dy dz ; group1 ; group2 ; group3 ; group4 ; group5 ; group6 ; group7 ; group8 ; group9 ; group10 ; group11 ; group12 ; group13 ; group14 ; group15<|action_end|>
```
- `dx dy dz`：鼠标相对位移 x、y 与滚轮 z
- `group1..group15`：每组为 33ms 内按下的键集合（空组允许，但必须保留分号位置）
- 组内按键以空格分隔；同键在相邻组重复 = 长按保持

---

## 1. 项目总体架构（Training + Runtime 共用）

### 1.1 项目结构图（ASCII）

```
                           +-------------------------+
                           |   External Task Graph   |
                           | Long Goal / Mid Goals   |
                           |  Mid Steps (id,text,    |
                           |   done_evidence_tpl)    |
                           +-----------+-------------+
                                       |
                                       v
+-------------------+       +----------+-----------+         +---------------------+
|   Collector        |----> | Dataset Builder      | ----->  |  Train Artifacts    |
|  video+raw input   |      |  clean/slice/align   |         |  LoRA weights,      |
|  -> action strings |      |  + VLM Labeler (DSL) |         |  prompts, schemas   |
+-------------------+       |  + Span alignment    |         +----------+----------+
                            |  + Retrieval fields  |                    |
                            +----------+-----------+                    v
                                       |                       +--------+---------+
                                       v                       | Evaluation Suite |
                          +------------+------------+          | offline + online |
                          |   Action Toolkit        |          +------------------+
                          | parse/validate/canon    |
                          +------------+------------+
                                       |
                                       v
+------------------------------------------------------------------------------------------------+
|                                         Runtime                                                |
|                                                                                                |
|  +-----------+   L0/L1 trigger   +-----------------+    need_plan     +--------------------+   |
|  | Capture   |-----------------> |   EventGate     | ---------------> | Planner (LoRA)      |  |
|  | 2 FPS     |                   | L0/L1/L2 cascade|                  | + retrieval inputs  |  |
|  +-----------+                   +--------+--------+                  | -> short_goal_dsl   |  |
|                                           |                           | -> plan_id/span cfg |  |
|                                           | write logs/updates        +----------+---------+   |
|                                           v                                      |             |
|                                   +-------+--------------------------------------+--------+    |
|                                   |           MCP (Timeline + Retrieval)                 |     |
|                                   | event_log / attempt_log / state_summary /            |     |
|                                   | step transitions / (optional) embedding index        |     |
|                                   +-------+--------------------------------------+--------+    |
|                                           |                                      |             |
|                                           | read short_goal_dsl + plan_id/span  | read         |
|                                           v                                      | recent+K    |
|                                   +-------+--------+                             |             |
|                                   | Controller     | <---------------------------+             |
|                                   | (LoRA)         |   history + short_goal_dsl                |
|                                   | -> action-only |                                           |
|                                   +-------+--------+                                           |
|                                           | parse/validate                                     |
|                                           v                                                    |
|                                   +-------+--------+                                           |
|                                   | Input Injector | 15x33ms tick                              |
|                                   +----------------+                                           |
+------------------------------------------------------------------------------------------------+
```

### 1.2 组件列表
- **Collector**：采集视频 + RawInput，对齐到 500ms step，生成 action string
- **Action Toolkit**：action parser / validator / canonicalizer（训练与推理共用）
- **Dataset Builder（含离线标注 + Span + Retrieval 对齐）**：清洗、切片、对齐；调用 VLM Labeler 生成 DSL short_goal；构造 plan span 与 retrieved_memory 字段
- **VLM Labeler（离线）**：对短视频片段生成结构化标签（DSL short_goal + done_evidence 等，含 terminate_on）
- **Planner（低频）**：运行时生成/更新 short_goal（DSL），并写入 MCP（含 plan_id 与 span 配置）
- **Controller（高频）**：执行 short_goal（DSL）并输出 action-only
- **EventGate（分级触发器）**：L0/L1 持续运行触发；L2 重感知仅在触发时运行
- **MCP（外置记忆/控制面板，增强版）**：Timeline Log + Retrieval
- **Runtime Orchestrator**：2FPS 调度、33ms 注入、门控与回退、日志写入、span 结束判定
- **Evaluation Suite**：离线指标 + 在线基准场景 + 回归测试

### 1.3 运行时闭环（每 500ms）
1) 捕获当前帧 `image_t`
2) `EventGate(L0/L1, image_t, history, last_actions) -> triggers/events`
3) 若 `need_L2=true`：运行 L2（OCR/更强检测/可选分割），补充 `events/state_summary`
4) 判断 `need_plan`：short_goal 过期/证据触发/卡住/死亡/关键 UI 弹窗等
5) 若 `need_plan=true`：
   - 冻结输入快照（recent_clip + summary_clip + MCP recent/topK）
   - Planner 从 MCP 读取：`recent_window(30–60s) + topK_related`
   - 异步调用 `Planner(recent_clip + summary_clip + mid_step + retrieved_memory) -> short_goal_dsl + done_evidence + plan_id + span_cfg + updates`
   - 写 MCP：short_goal + 迁移记录 + attempt 计划
6) 读 MCP 得到当前 `short_goal_dsl`（连同 `plan_id/span_cfg`）
7) 调用 `Controller(image_t + history + short_goal_dsl) -> action_str`
8) `ActionToolkit.parse/validate(action_str)`：不合法则 fallback
9) 按 33ms tick 依次执行 15 个 group（键鼠注入）
10) 更新 history（image/action pairs）
11) 写 MCP：event_log/state_summary/attempt_log（按策略采样）

---

## 2. 任务与目标表示

> A2 的关键是：**模型不负责从短视频猜长期语义**。长期/中期由外置流程提供，模型只在“已知当前步骤”的条件下生成并执行短期目标。

### 2.1 层级定义（区分 Mid Goal 与 Mid Step）
- **Long Goal（长期任务）**：会话级目标（例如“完成日常”）
- **Mid Goal（中期任务/流程块）**：可复用的大块流程（例如“刷副本、跑图、收菜”）
- **Mid Step（中期步骤）**：Mid Goal 内可判定完成的步骤序列；**`mid_step_id` 指向的就是 Mid Step**
- **Short Goal（短期目标）**：给 Controller 的 1–10 秒可执行意图；在本方案中用 **DSL** 表达，通常在同一 Mid Step 内多次迭代直到完成

### 2.2 你的例子落到层级（示例）
- **Long Goal**：完成日常
- **Mid Goals**：刷副本（`run_dungeon`）、跑图（`world_travel`）、收菜（`harvest_farming`）
- **Mid Steps（举例：跑图到城门接任务的一段）**：
  - `mid_step_id = go_gate_area`：前往城门附近 NPC 区域（证据：到达区域/导航 marker 变化等）
  - `mid_step_id = talk_gate_npc`：对准 NPC 并打开对话（证据：`dialog_open`）
  - `mid_step_id = accept_daily`：在对话中选择接取日常任务（证据：`quest_accept_popup` 或任务追踪更新）

### 2.3 Short Goal（用 DSL 表达，占位示例，不展开参数）
> 暂不讨论完整参数集，文档仅保留一个示例，后续再扩展 DSL 词表与参数。

```json
{
  "short_goal_dsl": [
    {"op": "MOVE_NAV", "args": {"...": "..."}},
    {"op": "INTERACT", "args": {"...": "..."}}
  ],
  "horizon_steps": 10,
  "done_evidence": ["dialog_open"],
  "fallback_if_failed": ["recenter_camera"]
}
```

---

## 3. Dataset Builder（数据构建 + VLM 标注 + Span 对齐 + Retrieval 字段构造）

### 3.1 Dataset Builder 输入
- episode：`{image_t}`（2FPS）
- 对齐动作：`{action_t}`（500ms action string）
- 外置任务图：`long_goal + mid_goals[] + mid_steps[]`（含 `mid_goal_id`, `mid_step_id`, `mid_step_text`, `done_evidence_template`）
- （可选）EventGate 预跑事件：用于采样关键片段与过滤
- （新增可选）Runtime 日志回流：MCP 的 `attempt_log / event_log / state_summary / transitions`（用于构造 retrieval 字段与失败恢复样本）

### 3.2 Dataset Builder 输出
- **Planner 训练集（Retrieval-aware）**：
  - input：`recent_clip + summary_clip + mid_goal_id + mid_step_id + mid_step_text + retrieved_memory`
  - target：`short_goal JSON（含 terminate_on；plan_id 由 Builder 注入）`
- **Controller 训练集（Span-aligned conditional BC）**：
  - input：`image_t + history + short_goal_dsl + plan_id`
  - target：`action_t`
  - 备注：每条样本来自某个 `plan span`（§3.5）
- EventGate 训练/校准集（可选）：UI 事件标签

### 3.3 数据构建流程（固化流水线，保留并扩展）
1) **清洗与对齐检查**：删除切后台/过场/加载过久/帧缺失；统计输入分布
2) **Action 规范化**：组内按键排序、去重、统一空白；dx/dy/dz clip
3) **mid_goal/mid_step 对齐**：
   - 最稳：脚本给出区间；
   - 半自动：UI 证据 + 规则切段 + 抽检。
4) **片段抽取（Planner/Labeler）**：
   - `recent_clip=[t-7..t]`（8 帧≈4 秒）
   - `summary_clip`：`[t-60s..t]` 每 2 秒采 1 帧（约 30 帧）
5) **离线 VLM Labeler 标注 short_goal（含 terminate_on）**：输出结构化 JSON + uncertainty
6) **构造 Planner 样本（Retrieval-aware，对齐点 1）**：
   - 从日志自动生成 `retrieved_memory={recent_window_events, topK_related}`（§3.4）
   - 将 retrieved_memory 与 recent_clip/summary_clip/mid_step 一起作为输入；target 为 Labeler 输出 JSON
7) **构造 Controller 样本（Span-aligned，对齐点 2）**：
   - 为每个 Labeler 输出建立 `plan span`（§3.5），把同一个 `short_goal_dsl` 分配给 span 内的每个时间步
   - 输入：`image_t + history + short_goal_dsl + plan_id`；target：`action_t`
8) **过滤与黄金集**：对 uncertainty=high 丢弃/复核；每个 mid_step 固定黄金集
9) **失败恢复样本回流**：从 attempt_log 挖掘连续失败→fallback→成功的片段，增强 Planner 训练

### 3.4 Retrieval 字段构造
> 目的：让 Planner 在训练时“看见”检索输入，否则上线时即便提供 recent/topK，模型也不会用。

**构造规则（最小可行）**
- `recent_window_events`：从 episode/日志中取最近 60 秒（或 30–60 秒）事件与尝试摘要（事件可采样/去重）
- `topK_related`：优先取：
  1) 同 `mid_step_id` 的最近 K 条 `attempt_log`（尤其是失败原因）
  2) 若不足，再取语义相似的 state_summary（如 OCR 关键字：地名/任务文本）

**语义检索两阶段**
- 阶段 1（无需 embedding）：同 mid_step 的最近 K 条 + 规则筛选（推荐先做）
- 阶段 2（embedding）：把 attempt/state_summary 文本化→向量索引；query 使用 `mid_step_text + recent_fail_reason`；取 topK

**训练/运行对齐要求**
- 统一检索策略与 query 生成规则（mid_step_text + recent_fail_reason + state_summary_keywords）
- 数据集写入 `retrieval_policy_version` 与 `retrieval_snapshot`，用于离线复现与回归
- `topK_related` 记录来源与置信度字段（source/type/score/time）

### 3.5 Plan Span 构造与对齐（Controller 训练对齐点 2，必须落地）
> 目的：把“一个 short_goal（DSL）”对齐到“一段 action 序列”，否则 conditional BC 数据不可用。

**Span 定义**
- 离线：Dataset Builder 为每个 Labeler short_goal 分配唯一 `plan_id`
- 运行时：Planner 为每次 short_goal 分配唯一 `plan_id`
- `plan span` 是该 plan_id 的生效区间：从 `t0` 开始，到 `t_end` 截止

**Span 起点**
- `t0`：产生 plan 的时间点（Labeler 在离线数据上可用采样点；运行时为 need_plan 触发时刻）

**Span 截断条件（优先级从高到低）**
1) `done_evidence_triggered`（证据触发）
2) `need_plan` 再次触发（重规划/策略切换）
3) 强干扰事件：`loading/menu_open/death_respawn/focus_lost/scene_change_high`
4) `horizon_steps` 到期（固定步数上限）

**证据稳定性要求**
- `done_evidence_triggered` 需满足稳定阈值（如 L1/L2 置信度高于阈值，或连续 N 帧一致）
- 证据不稳定时，先标记为 tentative，不立即结束 span

**Span 输出样本生成**
- 对 span 内每个 `t`：
  - input：`image_t + history + short_goal_dsl + plan_id`
  - target：`action_t`

**噪声控制**
- 若 span 内出现强干扰且持续，建议丢弃该 span 的后半段（或整段）以降低标签噪声
- 若证据噪声高且无法稳定确认，记录 `fail_reason` 并结束 span，避免污染训练样本

---

## 4. VLM Labeler（离线标注器：recent/summary clip → DSL short_goal，加入 terminate_on）

### 4.1 VLM Labeler 输入
- `recent_clip`：8 帧（4 秒；可调 2–6 秒）
- `summary_clip`：60 秒历史，每 2 秒采 1 帧（约 30 帧）
- `mid_goal_id`（可选但建议提供）
- `mid_step_id`（必选；指向当前 Mid Step）
- `mid_step_text`（必选）
- `constraints`（可选）
- （可选）`events/state_summary`：来自离线预跑的 L1/L2 结果（若可用）

### 4.2 VLM Labeler 输出（强制 JSON，更新）
> 新增字段：
> - `terminate_on`：终止策略提示（不涉及 DSL 参数细节）
>
> Builder 自动注入字段：
> - `schema_version`：JSON/DSL 版本号（用于回溯与兼容）
> - `plan_id`：用于 span 关联与追踪

```json
{
  "mid_step_id": "mid_XX",
  "short_goal_dsl": [{"op": "MOVE_NAV", "args": {"...": "..."}}],
  "horizon_steps": 10,
  "terminate_on": "done_evidence_or_replan|strict_horizon",
  "done_evidence": ["dialog_open"],
  "fallback_if_failed": ["recenter_camera"],
  "uncertainty": "low|mid|high"
}
```

### 4.3 VLM Labeler Prompt（模板）
**System**
- 你是游戏自动化数据标注助手。
- 给定短视频片段与当前步骤目标（Mid Step），请输出可执行的 short_goal（用 DSL 表示）以及可检测的完成证据。
- 你必须只输出 JSON，严格符合给定 schema，不得输出解释文字；不要输出 plan_id/schema_version。

**User**
- mid_goal_id: ...（可选）
- mid_step_id: ...
- mid_step_text: ...
- constraints: ...
- recent_clip: （8 帧）
- summary_clip: （30 帧，60 秒历史每 2 秒采 1 帧）
- done_evidence_enum: （枚举表）
- dsl_ops_enum: （枚举表）
- terminate_on_enum: ["done_evidence_or_replan", "strict_horizon"]

**Assistant**
- 输出 JSON

### 4.4 标注质量控制
- 必须输出 `uncertainty` 用于过滤与抽检
- 每个 `mid_step_id` 做固定比例人工复核（黄金集）
- 若某类 mid_step 输出不一致：先收紧 DSL op 枚举与 evidence 枚举，再重标注
- **强校验**：构建数据集时按 `schema_version` 校验字段与枚举一致性，不合格样本直接剔除

---

## 5. Planner（低频：mid_step + recent/summary clip + retrieval → short_goal_dsl，训练与运行统一）

### 5.1 Planner 输入
- `recent_clip`（必选，建议 4 秒）
- `summary_clip`（可选但建议：60 秒历史，每 2 秒采 1 帧）
- `mid_goal_id`（可选但建议）
- `mid_step_id`（必选）
- `mid_step_text`（必选）
- `prev_short_goal_dsl`（可选：用于平滑）
- `events`（可选：EventGate 输出）
- `state_summary`（可选：L1/L2 汇总结构化状态）
- **retrieved_memory（训练与运行统一接口）**：
  - `recent_window_events`：最近 30–60 秒事件/尝试摘要
  - `topK_related`：与当前 mid_step 语义相关的 K 条历史尝试/事件（失败原因、有效策略）

### 5.2 Planner 输出
- `plan_id`（必选）
- `short_goal_dsl`（必选）
- `horizon_steps`（必选） 指规划中本short goal剩余的帧数，如果到期则会自动调用Planner
- `terminate_on`（必选：终止策略提示）
- `done_evidence`（强烈推荐）
- `fallback_if_failed`（推荐）
- （可选）`updates`：对 MCP 的结构化更新（如“记录失败原因”“调整 cooldown”）

### 5.3 Planner 训练数据
- 监督信号来自 VLM Labeler 的 JSON
- 并通过“日志回流”的失败恢复样本增强鲁棒性
- **关键**：训练样本中必须显式提供 `retrieved_memory` 字段（由 Dataset Builder 构造，§3.4），以学习检索条件下的策略切换
- **对齐**：训练样本携带 `retrieval_policy_version` 与 `retrieval_snapshot`，评估时可回放同一检索输入做回归对比

### 5.4 Planner 运行时 Prompt（模板）
**System**
- 你是短期目标生成器。根据当前步骤目标（Mid Step）、近期片段与历史摘要片段，以及 MCP 提供的历史摘要（recent + topK），输出 short_goal（DSL）和完成证据。
- 只输出 JSON，严格 schema。

**User**
- mid_goal_id（可选）
- mid_step_id / mid_step_text
- prev_short_goal_dsl（可选）
- events/state_summary（可选）
- retrieved_memory:
  - recent_window_events: ...
  - topK_related: ...
- recent_clip
- summary_clip

**Assistant**
- JSON（含 plan_id/terminate_on）

### 5.5 Planner 注意细节
- **稳定性**：同一 mid_step 下短时间不要频繁改 short_goal（prev_short_goal + cooldown）
- **可执行性**：short_goal 必须是 1–10 秒级
- **显式利用历史**：当 topK 显示重复失败原因时，必须切换 fallback 或改策略

---

## 6. Controller（高频：short_goal_dsl + image/history → action-only，加入 plan_id）

### 6.1 Controller 输入
- `image_t + 短历史 (image/action pairs)`（推荐 4–20 steps）
- `short_goal_dsl`（必选，来自 MCP/Planner）
- `plan_id`（必选：用于训练/调试对齐；运行时可选但推荐保留）
- `constraints`（可选）

### 6.2 Controller 输出
- `action-only`：`<|action_start|>...<|action_end|>`

### 6.3 Controller 训练数据
- Stage1：`(image/history) -> action_t`（基本控制与格式）
- Stage2-A2（Span-aligned）：`(image/history + short_goal_dsl + plan_id) -> action_t`

### 6.4 Controller Prompt（模板）
**System**
- 你是实时游戏控制器。根据当前画面与 short_goal（DSL），输出未来 500ms 的键鼠动作。
- 你必须只输出一个动作字符串，严格遵循协议：
  `<|action_start|>dx dy dz ; g1 ; g2 ; g3 ; g4 ; g5 ; g6<|action_end|>`
- 不得输出任何解释文字、换行或引号。

**User**
- plan_id: ...
- short_goal_dsl: ...
- constraints: ...
- image_t（history 以多轮 image/action 形式提供）

**Assistant**
- action_str

### 6.5 Controller 注意细节
- **格式率优先**：输出必须可解析；不合法直接 fallback
- **抖动监控**：dx/dy 极端值与连续大幅转向要统计并回归
- **history 组织**：推荐 multi-turn（image/action 对话），增强连续控制
- **格式率门槛**：训练/评估 parse pass rate ≥ 99.9% 才允许进入下一阶段

---

## 7. EventGate（分级触发器：L0/L1/L2）

> 目标：持续低成本监控 + 只在必要时运行高成本感知（OCR/强检测/分割）。

### EventGate 输入
- `image_t`（必选）
- `image_{t-1}`（可选：用于帧差分）
- `action_{t-1..}`（可选：用于动作重复/no-op 检测）
- `window_state`（可选：窗口焦点/最小化/切换等）

### EventGate 输出
- `triggers_L0`：极便宜信号（布尔/计数/阈值触发）
- `events_L1`：便宜 UI 事件概率/标签
- `events_L2`：重感知补充结果（OCR 文本、强检测、可选分割）
- `need_plan`：是否调用 Planner
- `need_L2`：是否运行 L2（由 L0/L1 决定）

### 7.1 L0（极便宜，持续运行）
- frame diff、动作重复/no-op、窗口失焦/切换、stuck 规则

### 7.2 L1（便宜：UI 模板/轻量 CNN）
- dialog/menu/quest popup/loading/death 等事件概率

### 7.3 L2（重：OCR/强检测/可选分割，仅触发时运行）
- 触发条件：dialog/quest popup 高置信；scene_change；stuck；death；等
- **调度要求**：L2 必须异步执行，设置预算与超时（超过则丢弃该轮结果）
- **降级策略**：L2 未返回时，Planner/Controller 只使用 L0/L1 与上一版 state_summary

### 7.4 need_plan 判定（门控 Planner）
- `need_plan = OR(short_goal_expired, done_evidence_triggered, dialog_open, quest_popup, death_respawn, stuck_persistent)`

---

## 8. MCP

### 8.1 MCP 写入
- `event_log`：来自 EventGate L0/L1/L2 的事件（采样/去重）
- `state_summary`：L2 OCR/强检测汇总的结构化状态（低频写入）
- `short_goal_dsl`：Planner 输出（含 plan_id、terminate_on、horizon）
- `mid_step_transition`：mid_step 前进/回退记录（含证据）
- `attempt_log`：每次 plan span 结束写入 outcome（成功/失败/超时、失败原因、证据）

### 8.2 MCP 读取
- Controller：读取 `short_goal_dsl + plan_id + terminate_on/horizon`
- Planner：每次规划读取：
  - `recent_window (30–60s)`：事件/尝试摘要
  - `topK_related (K=3–8)`：与当前 mid_step 语义相关的历史尝试/事件

### 8.3 MCP Retrieval 接口（建议固化）
- `get_recent(window_s=60) -> {events, attempts, state_summaries}`
- `retrieve(query, k=5, filters={mid_step_id?, time_range?, source?}, policy_version=...) -> topK_items`
- `topK_items` 建议包含：`item_id/source/type/score/timestamp/summary`

### 8.4 MCP Schema（增强版最小字段示例，更新）
```json
{
  "session_id": "...",
  "long_goal": {"text": "完成日常", "status": "active|done|failed"},
  "current_mid_goal_id": "world_travel",
  "current_mid_step_id": "talk_gate_npc",

  "short_goal": {
    "plan_id": "plan_000123",
    "dsl": [{"op": "MOVE_NAV", "args": {"...": "..."}}],
    "horizon_steps": 10,
    "terminate_on": "done_evidence_or_replan",
    "done_evidence": ["dialog_open"],
    "fallback_if_failed": ["recenter_camera"],
    "created_at": 12345
  },

  "event_log": [{"t": 12342, "level": "L1", "event": "menu_open", "p": 0.92, "meta": {}}],
  "state_summaries": [{"t": 12342, "source": "L2", "ui_mode": "dialog", "ocr": {"title": "..."}}],

  "mid_step_transitions": [{"t": 12350, "from": "go_gate_area", "to": "talk_gate_npc", "evidence": ["arrived_gate_area"]}],

  "attempt_log": [{
    "plan_id": "plan_000122",
    "t0": 12320, "t1": 12330,
    "mid_step_id": "talk_gate_npc",
    "short_goal_dsl": [{"op": "INTERACT", "args": {"...": "..."}}],
    "outcome": "fail",
    "evidence_seen": [],
    "fail_reason": "no_dialog_open"
  }],

  "rolling_summary": "过去20秒：尝试交互2次无对话框…",
  "failure_counters": {"stuck": 1, "death": 0}
}
```

---

## 9. Runtime Orchestrator（闭环调度与输入注入）

### Orchestrator 输入
- `image_t`（2FPS）
- history buffer
- MCP 状态（short_goal + plan_id/horizon/terminate_on、recent summary）
- EventGate L0/L1 triggers 与（可选）L2 结果

### Orchestrator 输出
- Planner/Controller 调用决策
- L2 是否运行
- 33ms tick 注入序列
- MCP 写入：event/state_summary/attempt/span 结束记录

### Orchestrator 核心流程（每 500ms）
1) capture `image_t`
2) EventGate L0/L1：得到 `need_L2 / events_L1 / stuck_suspect`
3) 若 `need_L2`：异步运行 L2 → `state_summary/events_L2`（超时丢弃，不阻塞 500ms loop）
4) 写 MCP：event_log（采样/去重）、必要时写 state_summary
5) 判定 `need_plan`：
   - short_goal 过期；
   - done_evidence 触发；
   - dialog/quest popup/death；
   - stuck 规则。
6) **若当前 plan span 结束**（基于 §3.5 截断条件）：
   - 写 attempt_log（plan_id、outcome、fail_reason、evidence_seen）
7) 若 `need_plan`：
   - 冻结输入快照（recent_clip + summary_clip + MCP recent/topK）
   - 从 MCP 取 `recent_window(30–60s)`
   - 构造 query，取 `topK_related`
   - 异步调 Planner（Planner-LoRA）生成 new short_goal（含新 plan_id/terminate_on）
   - 写 MCP：short_goal +（可选）step 迁移
8) 调 Controller（Controller-LoRA）输出 action
9) ActionToolkit 校验/解析，不合法 fallback
10) 15×33ms tick 注入输入
11) 更新 history

### 安全回退
- action 解析失败：fallback 到 no-op（或安全退避动作）
- dx/dy 过大：clip
- 连续 no-op：触发 stuck_rule → need_plan

### 9.1 33ms Tick 时间基准与漂移处理
- 以单调时钟为基准，维持 15×33ms 的节拍
- 记录 drift（累计偏差），每 N 帧进行微调补偿
- 若 drift 超过阈值，降级为 500ms 单次注入并记录告警

---

## 10. Action Toolkit（解析/校验/规范化）

### Action Toolkit 输入
- 训练：采集 action string
- 推理：模型生成 action string

### Action Toolkit 输出
- `parsed_action = (dx,dy,dz, chunks[6])`
- `is_valid`
- `canonical_action`（可选）

### 关键规则
- chunk 数量必须为 6
- 键必须属于白名单
- dx/dy/dz 在范围内（超出则 clip 或判 invalid）

---

## 11. 单底座模型 + 双 LoRA 切换（实现原则）

- **Controller-LoRA（ControlAdapter）**：高频执行，输出 action-only
- **Planner-LoRA（TaskAdapter）**：低频生成 short_goal_dsl JSON（含 plan_id/terminate_on）

切换原则：按“调用角色”切换 LoRA，不在同一次前向叠加。

### 11.1 运行时推理栈建议
- 运行环境：Windows + WSL2（Ubuntu 22.04）
- 驱动与 CUDA：Windows NVIDIA 驱动 + CUDA 12.x
- 框架：PyTorch 2.3+（CUDA build） + `transformers` + `peft` + `accelerate`
- 性能与显存：
  - 优先 FP16；若显存不够，基座权重用 8bit/4bit（`bitsandbytes`），LoRA 保持 FP16
  - 使用 PyTorch SDPA（默认），暂不依赖 vLLM/Flash-Attn/TensorRT

---

## 12. 训练计划

### Phase A：Controller Stage1（ControlAdapter）
- 目标：协议稳定 + 基础操控
- 数据：无 short_goal
- 验收：格式率≥99.9%，在线 10min 不失控

### Phase B：离线标注管线（Labeler）
- 目标：为每个 mid_step 产出一致的 short_goal_dsl（含 terminate_on）
- 输出：Planner 训练集 + 黄金集

### Phase C：Planner 训练（TaskAdapter，Retrieval-aware）
- 目标：在线替代离线 labeler 生成 short_goal_dsl
- 训练：labeler 输出做监督；黄金集加权；引入失败恢复回流样本
- **关键**：训练时必须喂 `retrieved_memory`（recent + topK），学习利用检索信息避免重复失败
- 验收：输出 schema 合法、变化率稳定、done_evidence 合理；检索条件下重复失败率下降

### Phase D：Controller 条件执行（Span-aligned）
- 目标：执行 DSL short_goal 时控制不退化
- **关键**：训练样本来自 plan span 对齐数据（§3.5）
- 课程学习配比：
  - 初期 80:20（Stage1:Stage2）
  - 中期 60:40
  - 后期 50:50（以控制指标不下降为硬约束）

---

## 13. 评估与回归测试

### 离线评估
- **格式正确率**（parser pass rate）
- **dx/dy/dz MAE** 与分布漂移
- **keyset F1/Jaccard**（每个 33ms chunk）
- **抖动 proxy**：连续大幅转向、方向频繁翻转
- **short_goal 稳定性**：同 mid_step 内短时间输出变化率
- **retrieval 有效性**：同一步骤连续失败时，Planner 是否降低重复失败率（对比无 retrieval 输入的 ablation）
- **span 噪声指标（建议）**：强干扰事件占比、span 截断原因分布、span 内 action 与 goal 相关性 proxy

### 在线评估（固定基准场景）
- 跑图（低对抗）
- 战斗（高动态）
- UI/交互（对话、拾取、菜单）

记录：步骤完成率（按 mid_step）、平均时间、失败类型（卡 UI/乱转/死亡/偏航）

---

## 14. 常见坑与对策（A2 + DSL + MCP/分级EventGate + 两点对齐）

1) **DSL 不收敛（Labeler 写法千奇百怪）**
   - 对策：收紧 DSL op 枚举与 evidence 枚举；强制 JSON schema；uncertainty 过滤

2) **Controller 输出被污染（开始输出解释文本）**
   - 对策：action-only 强 system + 推理校验 fallback；训练集只包含 action-only 目标

3) **Planner 频繁改 short_goal（抖动）**
   - 对策：输入 prev_short_goal；运行时 cooldown；训练加入稳定性示例

4) **done_evidence 不可靠导致步骤卡死**
   - 对策：优先 UI 强证据（L1/L2）；弱证据需多帧一致或规则兜底

5) **L2 运行过频导致延迟抖动**
   - 对策：只在 L0/L1 触发时运行；加 L2 冷却；OCR 小区域裁剪

6) **检索把噪声喂给 Planner**
   - 对策：topK 仅选与当前 mid_step 匹配或最近失败原因相关的 item；对日志做去重与摘要

7) **没有 span 对齐导致 Controller conditional 数据不可用**
   - 对策：严格按 §3.5 构造 span；强干扰事件截断；必要时丢弃高噪声 span

8) **33ms tick 不准破坏连段/闪避窗口**
   - 对策：记录 drift；必要时补偿；保证注入线程优先级

---

## 15. MVP 清单
- [ ] Action Toolkit（parse/validate/canonicalize）
- [ ] Controller Stage1 LoRA（格式率与稳定性）
- [ ] Orchestrator（500ms loop + 33ms tick）
- [ ] MCP（增强版：event_log/state_summary/attempt_log/step transitions + recent window API + retrieve API stub）
- [ ] EventGate L0/L1（帧差分/动作重复/no-op + UI 模板/轻量 CNN）
- [ ] L2（OCR/强 UI 检测）仅在触发时运行
- [ ] Labeler（离线 VLM 输出 short_goal_dsl JSON，含 terminate_on）
- [ ] Dataset Builder：
- [ ] 构造 Planner 的 retrieval 字段（recent + topK）
- [ ] 构造 Controller 的 plan span 对齐数据
- [ ] Planner LoRA（在线生成 short_goal_dsl；读取 recent+topK）
- [ ] 离线评估 + 在线回归场景
